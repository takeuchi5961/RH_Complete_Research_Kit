<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Zeta Quad-View Station - Fixed</title>
    <style>
        body { margin: 0; background: #000; color: #0ff; font-family: 'Inter', sans-serif; overflow: hidden; }
        #info {
            position: absolute; bottom: 20px; left: 20px;
            z-index: 100; pointer-events: none; border-left: 2px solid #ff6600; padding-left: 10px;
        }
        .stat { font-size: 18px; font-weight: bold; }
        /* 画面右側のUI（補足） */
        #labels {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
            pointer-events: none;
        }
        .label {
            padding: 10px; font-size: 10px; color: #888; letter-spacing: 2px;
            border: 0.5px solid rgba(0,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="info">
        <div style="font-size: 10px; color: #888;">T-AXIS PROGRESS</div>
        <div id="valT" class="stat">0.00</div>
        <div id="valZ" class="stat" style="color:#ff6600; margin-top:5px;">ZEROS: 0</div>
    </div>

    <div id="labels">
        <div class="label">TOP (RE / IM)</div>
        <div class="label">PERSPECTIVE</div>
        <div class="label">FRONT (RE / T)</div>
        <div class="label">RIGHT (IM / T)</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // --- 数学エンジン (Riemann-Siegel) ---
        const theta = t => (t/2) * Math.log(t / (2 * Math.PI)) - (t/2) - (Math.PI/8) + (1/(48*t));
        const computeZ = t => {
            const N = Math.floor(Math.sqrt(t / (2 * Math.PI)));
            let sum = 0;
            const th = theta(t);
            for (let n = 1; n <= N; n++) sum += (1 / Math.sqrt(n)) * Math.cos(th - t * Math.log(n));
            return 2 * sum;
        };

        let t = 10.0;
        let lastZval = 0, zeroCount = 0;
        let history = [];
        const historyLimit = 600;

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // カメラ設定
        const aspect = (window.innerWidth/2) / (window.innerHeight/2);
        const d = 10;
        const views = [
            { // TOP
                left: 0, bottom: 0.5, width: 0.5, height: 0.5,
                cam: new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 0.1, 2000),
                pos: [0, 0, 100], up: [0, 1, 0]
            },
            { // PERSP
                left: 0.5, bottom: 0.5, width: 0.5, height: 0.5,
                cam: new THREE.PerspectiveCamera(45, aspect, 0.1, 2000),
                pos: [15, 12, 20], up: [0, 1, 0], orbit: true
            },
            { // FRONT
                left: 0, bottom: 0, width: 0.5, height: 0.5,
                cam: new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 0.1, 2000),
                pos: [0, 100, -15], up: [0, 0, 1] // T軸(Z)を横にするため調整
            },
            { // RIGHT
                left: 0.5, bottom: 0, width: 0.5, height: 0.5,
                cam: new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 0.1, 2000),
                pos: [100, 0, -15], up: [0, 0, 1]
            }
        ];

        views.forEach(v => {
            v.cam.position.set(...v.pos);
            v.cam.lookAt(0, 0, v.id === 'viewTop' ? 0 : -15);
            if(v.orbit) {
                v.controls = new THREE.OrbitControls(v.cam, renderer.domElement);
            }
        });

        // 共通ヘルパー
        const grid = new THREE.GridHelper(40, 40, 0x222222, 0x111111);
        grid.rotation.x = Math.PI/2;
        scene.add(grid);
        
        // 軸の描画（中心線）
        const createAxis = (points, color) => {
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            return new THREE.Line(geo, new THREE.LineBasicMaterial({ color }));
        };
        scene.add(createAxis([new THREE.Vector3(0,0,10), new THREE.Vector3(0,0,-1000)], 0x444444)); // T軸

        const trail = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x00ffff }));
        scene.add(trail);

        function animate() {
            requestAnimationFrame(animate);

            // 計算更新
            for(let i=0; i<2; i++) {
                t += 0.03;
                const cz = computeZ(t), th = theta(t);
                const x = cz * Math.cos(th), y = -cz * Math.sin(th);

                if ((lastZval > 0 && cz <= 0) || (lastZval < 0 && cz >= 0)) {
                    spawnZeroMarker();
                    zeroCount++;
                }
                lastZval = cz;
                history.unshift(new THREE.Vector3(x, y, -history.length * 0.25)); 
            }

            // 軌跡の奥行きを更新しながら再構築
            const displayPts = history.map((p, i) => new THREE.Vector3(p.x, p.y, -i * 0.25));
            if (history.length > historyLimit) history.pop();
            trail.geometry.setFromPoints(displayPts);

            // 4画面それぞれのレンダリング
            const w = window.innerWidth;
            const h = window.innerHeight;

            views.forEach(v => {
                const left = v.left * w;
                const bottom = v.bottom * h;
                const width = v.width * w;
                const height = v.height * h;

                renderer.setViewport(left, bottom, width, height);
                renderer.setScissor(left, bottom, width, height);
                renderer.setScissorTest(true);
                
                if(v.controls) v.controls.update();
                renderer.render(scene, v.cam);
            });

            document.getElementById('valT').textContent = t.toFixed(2);
            document.getElementById('valZ').textContent = `ZEROS: ${zeroCount}`;
        }

        const markers = [];
        function spawnZeroMarker() {
            const m = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.05, 8, 24), new THREE.MeshBasicMaterial({ color: 0xff6600 }));
            scene.add(m);
            markers.push(m);
        }

        // マーカーの後退処理
        setInterval(() => {
            markers.forEach(m => m.position.z -= 0.5);
        }, 16);

        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            const newAspect = (w/2) / (h/2);
            views.forEach(v => {
                if(v.cam.isPerspectiveCamera) {
                    v.cam.aspect = newAspect;
                } else {
                    v.cam.left = -d * newAspect; v.cam.right = d * newAspect;
                }
                v.cam.updateProjectionMatrix();
            });
        });

        animate();
    </script>
</body>
</html>