<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RH 幾何 + 波形モデル</title>
    <style>
        :root {
            --bg: #0a0a0f;
            --grid: #1a1a2e;
            --axis: #3a3a5e;
            --text: #e0e0e0;
            --accent: #00d4ff;
            --critical: #ff3366;
            --point-a: #ff6b35;
            --point-b: #7bed9f;
            --point-c: #a855f7;
            --point-d: #ffd93d;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            padding: 10px;
        }
        h1 { font-size: 1rem; font-weight: 400; letter-spacing: 0.1em; margin-bottom: 10px; color: var(--accent); text-align: center; }
        .main-container { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        .canvas-section { display: flex; flex-direction: column; gap: 4px; }
        .canvas-wrapper { background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%); border: 1px solid var(--axis); border-radius: 4px; padding: 5px; }
        .canvas-label { font-size: 0.7rem; color: var(--accent); padding: 2px 6px; background: rgba(0, 212, 255, 0.1); border-radius: 2px; text-align: center; }
        canvas { display: block; }
        .controls { background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%); border: 1px solid var(--axis); border-radius: 4px; padding: 10px; width: 220px; font-size: 0.7rem; }
        .control-group { margin-bottom: 8px; }
        .control-group label { display: block; margin-bottom: 3px; font-size: 0.65rem; color: var(--accent); }
        .input-row { display: flex; gap: 5px; align-items: center; }
        input[type="text"] { flex: 1; background: var(--bg); border: 1px solid var(--axis); color: var(--text); padding: 5px; font-family: inherit; font-size: 0.75rem; border-radius: 2px; }
        .slider-container { display: flex; align-items: center; gap: 5px; }
        input[type="range"] { flex: 1; -webkit-appearance: none; background: var(--axis); height: 3px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; cursor: pointer; }
        .value-display { font-size: 0.7rem; min-width: 50px; text-align: right; color: var(--critical); }
        .buttons { display: flex; gap: 4px; margin-bottom: 6px; flex-wrap: wrap; }
        button { padding: 5px 8px; background: transparent; border: 1px solid var(--accent); color: var(--accent); font-family: inherit; font-size: 0.65rem; cursor: pointer; border-radius: 2px; }
        button:hover { background: var(--accent); color: var(--bg); }
        button.primary { border-color: var(--critical); color: var(--critical); }
        button.primary:hover { background: var(--critical); color: var(--bg); }
        .info { font-size: 0.55rem; line-height: 1.4; color: #888; border-top: 1px solid var(--axis); padding-top: 5px; margin-top: 5px; }
        .info-row { display: flex; justify-content: space-between; }
        .info-value { color: var(--text); }
        .info-value.critical { color: var(--critical); font-weight: bold; }
        .info-value.match { color: #7bed9f; font-weight: bold; }
        .section-title { color: var(--accent); font-size: 0.7rem; margin: 6px 0 3px 0; border-bottom: 1px solid var(--axis); padding-bottom: 2px; }
    </style>
</head>
<body>
    <h1>RH 幾何 + 波形モデル</h1>
    <div class="main-container">
        <div class="canvas-section">
            <div class="canvas-label">複素数グラフ</div>
            <div class="canvas-wrapper">
                <canvas id="geomCanvas" width="420" height="420"></canvas>
            </div>
        </div>
        
        <div class="canvas-section">
            <div class="canvas-label">波形グラフ</div>
            <div class="canvas-wrapper">
                <canvas id="waveCanvas" width="450" height="420"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <div class="section-title">パラメータ</div>
            <div class="control-group">
                <label>R₀</label>
                <div class="input-row">
                    <input type="text" id="r0-input" value="0.5">
                    <button class="primary" id="r0-set-btn">SET</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>θ（回転角）</label>
                <div class="slider-container">
                    <input type="range" id="theta-slider" min="0" max="12.5664" step="0.001" value="0">
                    <span class="value-display" id="theta-value">0°</span>
                </div>
            </div>
            
            <div class="buttons">
                <button id="play-btn">▶ 再生</button>
                <button id="reset-btn">↺</button>
            </div>
            
            <div class="section-title">複素数グラフ</div>
            <div class="info">
                <div class="info-row"><span>D</span><span class="info-value" id="d-pos">—</span></div>
                <div class="info-row"><span>|CD|</span><span class="info-value" id="cd-dist">—</span></div>
                <div class="info-row"><span>D on X軸?</span><span class="info-value" id="d-on-x">—</span></div>
            </div>
            
            <div class="section-title">波形グラフ</div>
            <div class="info">
                <div class="info-row"><span>|D→T|</span><span class="info-value" id="dt-len">—</span></div>
                <div class="info-row"><span>T 頂点?</span><span class="info-value" id="t-peak">—</span></div>
            </div>
            
            <div class="section-title">零点</div>
            <div class="info">
                <div class="info-row"><span>D.x = 0?</span><span class="info-value" id="is-zero">—</span></div>
            </div>
            
            <div style="font-size:0.5rem; color:#666; margin-top:8px; line-height:1.4;">
                <p>複素数 D が X軸またぐ</p>
                <p>→ 波形 T が頂点</p>
                <p style="color:var(--critical)">D.x = 0 → 零点</p>
            </div>
        </div>
    </div>
    
    <script>
        // ========== 複素数グラフ ==========
        const geomCanvas = document.getElementById('geomCanvas');
        const geomCtx = geomCanvas.getContext('2d');
        const GW = geomCanvas.width, GH = geomCanvas.height;
        const GCX = GW / 2, GCY = GH / 2, GSCALE = 130;
        
        // ========== 波形グラフ ==========
        const waveCanvas = document.getElementById('waveCanvas');
        const waveCtx = waveCanvas.getContext('2d');
        const WW = waveCanvas.width, WH = waveCanvas.height;
        
        // ========== 状態 ==========
        let R0 = 0.5;
        let theta = 0;
        let isPlaying = false;
        let lastTime = 0;
        
        // ========== DOM ==========
        const r0Input = document.getElementById('r0-input');
        const r0SetBtn = document.getElementById('r0-set-btn');
        const thetaSlider = document.getElementById('theta-slider');
        const thetaValueEl = document.getElementById('theta-value');
        const playBtn = document.getElementById('play-btn');
        const resetBtn = document.getElementById('reset-btn');
        const dPosEl = document.getElementById('d-pos');
        const cdDistEl = document.getElementById('cd-dist');
        const dOnXEl = document.getElementById('d-on-x');
        const dtLenEl = document.getElementById('dt-len');
        const tPeakEl = document.getElementById('t-peak');
        const isZeroEl = document.getElementById('is-zero');
        
        // ========== イベント ==========
        r0SetBtn.addEventListener('click', () => {
            const val = parseFloat(r0Input.value);
            if (!isNaN(val) && val > 0 && val < 2) R0 = val;
        });
        r0Input.addEventListener('keypress', e => { if (e.key === 'Enter') r0SetBtn.click(); });
        
        thetaSlider.addEventListener('input', e => {
            theta = parseFloat(e.target.value);
            thetaValueEl.textContent = (theta * 180 / Math.PI).toFixed(1) + '°';
            isPlaying = false;
            playBtn.textContent = '▶ 再生';
        });
        
        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '⏸' : '▶ 再生';
        });
        
        resetBtn.addEventListener('click', () => {
            theta = 0;
            thetaSlider.value = 0;
            thetaValueEl.textContent = '0°';
            isPlaying = false;
            playBtn.textContent = '▶ 再生';
        });
        
        // ========== 計算 ==========
        function getBD() { return 1 - R0; }
        
        function getD(t) {
            const bd = getBD();
            return {
                x: R0 + bd * Math.cos(-t),
                y: bd * Math.sin(-t)
            };
        }
        
        // ========== 複素数グラフ描画（元のモデルを再現） ==========
        function toGeomX(x) { return GCX + x * GSCALE; }
        function toGeomY(y) { return GCY - y * GSCALE; }
        
        function drawGeom(D) {
            const ctx = geomCtx;
            const bd = getBD();
            const A = { x: -R0, y: 0 };
            const B = { x: R0, y: 0 };
            const O = { x: 0, y: 0 };
            const C = { x: 0, y: D.y };  // C は Y軸上、D.y に自動調整
            
            const dOnX = Math.abs(D.y) < 0.03;
            const isZero = Math.abs(D.x) < 0.02;
            const cd = Math.abs(D.x);  // |CD| = |D.x| （C.x = 0, C.y = D.y なので）
            
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, GW, GH);
            
            // グリッド
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i += 0.5) {
                ctx.beginPath(); ctx.moveTo(toGeomX(i), 0); ctx.lineTo(toGeomX(i), GH); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, toGeomY(i)); ctx.lineTo(GW, toGeomY(i)); ctx.stroke();
            }
            
            // 軸
            ctx.strokeStyle = dOnX ? '#00ff00' : '#3a3a5e';
            ctx.lineWidth = dOnX ? 3 : 2;
            ctx.beginPath(); ctx.moveTo(0, GCY); ctx.lineTo(GW, GCY); ctx.stroke();
            
            ctx.strokeStyle = '#3a3a5e';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(GCX, 0); ctx.lineTo(GCX, GH); ctx.stroke();
            
            // 軸ラベル
            ctx.fillStyle = '#666';
            ctx.font = '11px Courier New';
            ctx.fillText('Re', GW - 25, GCY - 8);
            ctx.fillText('Im', GCX + 8, 18);
            
            // D 軌道円
            ctx.beginPath();
            ctx.arc(toGeomX(B.x), toGeomY(B.y), bd * GSCALE, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.25)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            
            // C の水平線
            ctx.beginPath();
            ctx.moveTo(0, toGeomY(C.y));
            ctx.lineTo(GW, toGeomY(C.y));
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]); ctx.stroke(); ctx.setLineDash([]);
            
            // D から Y軸への垂線
            if (Math.abs(D.x) > 0.01) {
                ctx.beginPath();
                ctx.moveTo(toGeomX(D.x), toGeomY(D.y));
                ctx.lineTo(toGeomX(0), toGeomY(D.y));
                ctx.strokeStyle = 'rgba(255, 217, 61, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]); ctx.stroke(); ctx.setLineDash([]);
            }
            
            // 線
            ctx.setLineDash([]);
            ctx.lineWidth = 2;
            
            // A-D
            ctx.strokeStyle = '#ff6b35';
            ctx.beginPath(); ctx.moveTo(toGeomX(A.x), toGeomY(A.y)); ctx.lineTo(toGeomX(D.x), toGeomY(D.y)); ctx.stroke();
            
            // B-D
            ctx.strokeStyle = '#7bed9f';
            ctx.beginPath(); ctx.moveTo(toGeomX(B.x), toGeomY(B.y)); ctx.lineTo(toGeomX(D.x), toGeomY(D.y)); ctx.stroke();
            
            // C-D
            ctx.strokeStyle = isZero ? '#ff3366' : 'rgba(168, 85, 247, 0.8)';
            ctx.lineWidth = isZero ? 3 : 2;
            ctx.beginPath(); ctx.moveTo(toGeomX(C.x), toGeomY(C.y)); ctx.lineTo(toGeomX(D.x), toGeomY(D.y)); ctx.stroke();
            
            // 点
            function pt(x, y, col, lbl, r = 6) {
                ctx.beginPath(); ctx.arc(toGeomX(x), toGeomY(y), r, 0, Math.PI * 2);
                ctx.fillStyle = col; ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = 'bold 11px Courier New';
                ctx.fillText(lbl, toGeomX(x) + r + 3, toGeomY(y) - r);
            }
            
            pt(O.x, O.y, '#ff3366', 'O', 5);
            pt(A.x, A.y, '#ff6b35', 'A', 6);
            pt(B.x, B.y, '#7bed9f', 'B', 6);
            pt(C.x, C.y, '#a855f7', 'C', 7);
            
            // D の Y軸上射影
            if (Math.abs(D.x) > 0.01) {
                ctx.beginPath();
                ctx.arc(toGeomX(0), toGeomY(D.y), 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 217, 61, 0.5)';
                ctx.fill();
            }
            
            // D
            let dColor = '#ffd93d';
            if (isZero) dColor = '#ff3366';
            else if (dOnX) dColor = '#00ff00';
            pt(D.x, D.y, dColor, 'D', 8);
            
            // 情報
            ctx.fillStyle = '#00d4ff';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`R₀=${R0}  |BD|=${bd.toFixed(4)}`, GCX, GH - 35);
            ctx.fillText(`θ=π での D.x = ${(R0 - bd).toFixed(4)}`, GCX, GH - 20);
            
            const critical = Math.abs(R0 - 0.5) < 0.001;
            ctx.fillStyle = critical ? '#ff3366' : '#888';
            ctx.fillText(critical ? '★ R₀ = 0.5: 臨界値 ★' : '', GCX, GH - 5);
            
            return { dOnX, isZero, cd };
        }
        
        // ========== 波形グラフ描画 ==========
        function drawWave(D, dOnX, isZero) {
            const ctx = waveCtx;
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, WW, WH);
            
            const marginL = 50;
            const marginR = 20;
            const marginT = 40;
            const marginB = 50;
            const plotW = WW - marginL - marginR;
            const plotH = WH - marginT - marginB;
            const plotX = marginL;
            const plotY = marginT;
            const centerY = plotY + plotH / 2;
            
            const bd = getBD();
            const A_val = -R0;
            const maxHeight = R0 + bd;
            const yRange = maxHeight * 1.3;
            
            function toX(t) { return plotX + (t / (4 * Math.PI)) * plotW; }
            function toY(h) { return centerY - (h / yRange) * (plotH / 2); }
            
            // グリッド
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = toX(i * Math.PI);
                ctx.beginPath(); ctx.moveTo(x, plotY); ctx.lineTo(x, plotY + plotH); ctx.stroke();
            }
            
            // X軸
            ctx.strokeStyle = '#3a3a5e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(plotX, centerY);
            ctx.lineTo(plotX + plotW, centerY);
            ctx.stroke();
            
            // Y軸
            ctx.beginPath();
            ctx.moveTo(plotX, plotY);
            ctx.lineTo(plotX, plotY + plotH);
            ctx.stroke();
            
            // A 基準線
            const A_screenY = toY(A_val);
            ctx.strokeStyle = 'rgba(255, 107, 53, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(plotX, A_screenY);
            ctx.lineTo(plotX + plotW, A_screenY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 軸ラベル
            ctx.fillStyle = '#555';
            ctx.font = '9px Courier New';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 4; i++) {
                ctx.fillText(i + 'π', toX(i * Math.PI), plotY + plotH + 15);
            }
            ctx.fillText('θ', plotX + plotW / 2, plotY + plotH + 35);
            
            ctx.textAlign = 'right';
            ctx.fillText(yRange.toFixed(2), plotX - 5, plotY + 8);
            ctx.fillText('0', plotX - 5, centerY + 3);
            
            // 波形（T の高さ = D.x）
            ctx.beginPath();
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            let first = true;
            for (let t = 0; t <= 4 * Math.PI; t += 0.02) {
                const Dt = getD(t);
                const h = Dt.x;
                const x = toX(t);
                const y = toY(h);
                if (first) { ctx.moveTo(x, y); first = false; }
                else { ctx.lineTo(x, y); }
            }
            ctx.stroke();
            
            // 頂点マーカー（D.y = 0 のとき）
            ctx.fillStyle = '#00ff00';
            for (let i = 0; i <= 4; i++) {
                const t = i * Math.PI;
                const Dt = getD(t);
                ctx.beginPath();
                ctx.arc(toX(t), toY(Dt.x), 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 零点マーカー
            if (Math.abs(R0 - 0.5) < 0.01) {
                ctx.fillStyle = '#ff3366';
                for (let i = 1; i <= 3; i += 2) {
                    const t = i * Math.PI;
                    ctx.beginPath();
                    ctx.arc(toX(t), toY(0), 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 現在位置
            const currentX = toX(theta);
            const T_height = D.x;
            const T_screenY = toY(T_height);
            const C_screenY = T_screenY;
            const dtLength = D.x;
            
            // A 点
            ctx.beginPath();
            ctx.arc(plotX, A_screenY, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6b35';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText('A', plotX - 8, A_screenY + 3);
            
            // D 点（X軸上）
            ctx.beginPath();
            ctx.arc(currentX, centerY, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#ffd93d';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('D', currentX, centerY + 18);
            
            // D → T ベクトル
            ctx.strokeStyle = '#ffd93d';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(currentX, centerY);
            ctx.lineTo(currentX, T_screenY);
            ctx.stroke();
            
            // 矢印
            if (Math.abs(dtLength) > 0.01) {
                const dir = dtLength > 0 ? -1 : 1;
                ctx.beginPath();
                ctx.moveTo(currentX, T_screenY);
                ctx.lineTo(currentX - 5, T_screenY + dir * 8);
                ctx.lineTo(currentX + 5, T_screenY + dir * 8);
                ctx.closePath();
                ctx.fillStyle = '#ffd93d';
                ctx.fill();
            }
            
            // A → T ベクトル
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(plotX, A_screenY);
            ctx.lineTo(currentX, T_screenY);
            ctx.stroke();
            
            // T → C ベクトル
            ctx.strokeStyle = isZero ? '#ff3366' : '#a855f7';
            ctx.lineWidth = isZero ? 3 : 2;
            ctx.beginPath();
            ctx.moveTo(currentX, T_screenY);
            ctx.lineTo(plotX, C_screenY);
            ctx.stroke();
            
            // T 点
            let tColor = '#00d4ff';
            if (isZero) tColor = '#ff3366';
            else if (dOnX) tColor = '#00ff00';
            ctx.beginPath();
            ctx.arc(currentX, T_screenY, 6, 0, Math.PI * 2);
            ctx.fillStyle = tColor;
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.fillText('T', currentX + 8, T_screenY - 3);
            
            // C 点
            ctx.beginPath();
            ctx.arc(plotX, C_screenY, 5, 0, Math.PI * 2);
            ctx.fillStyle = isZero ? '#ff3366' : '#a855f7';
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'right';
            ctx.fillText('C', plotX - 8, C_screenY + 3);
            
            // 状態表示
            if (dOnX) {
                ctx.fillStyle = '#00ff00';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText('★ T 頂点（D on X軸）', plotX + 10, plotY + 15);
            }
            if (isZero) {
                ctx.fillStyle = '#ff3366';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('★ 零点 ★', plotX + plotW / 2, plotY + 20);
            }
            
            // 凡例
            ctx.font = '8px Courier New';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('● 頂点', plotX + plotW - 5, plotY + 15);
            ctx.fillStyle = '#ff3366';
            ctx.fillText('● 零点', plotX + plotW - 5, plotY + 28);
            
            return dtLength;
        }
        
        // ========== メインループ ==========
        function animate(timestamp) {
            if (isPlaying && lastTime) {
                theta += (timestamp - lastTime) / 2000;
                if (theta > 4 * Math.PI) theta = 0;
                thetaSlider.value = Math.min(theta, 12.5664);
                thetaValueEl.textContent = (theta * 180 / Math.PI).toFixed(1) + '°';
            }
            lastTime = timestamp;
            
            const D = getD(theta);
            const { dOnX, isZero, cd } = drawGeom(D);
            const dtLength = drawWave(D, dOnX, isZero);
            
            // 情報更新
            dPosEl.textContent = `(${D.x.toFixed(3)}, ${D.y.toFixed(3)})`;
            cdDistEl.textContent = cd.toFixed(6);
            
            dOnXEl.textContent = dOnX ? 'YES' : 'NO';
            dOnXEl.className = dOnX ? 'info-value match' : 'info-value';
            
            dtLenEl.textContent = dtLength.toFixed(4);
            
            tPeakEl.textContent = dOnX ? 'YES ▲' : 'NO';
            tPeakEl.className = dOnX ? 'info-value match' : 'info-value';
            
            isZeroEl.textContent = isZero ? 'YES ★' : 'NO';
            isZeroEl.className = isZero ? 'info-value critical' : 'info-value';
            
            requestAnimationFrame(animate);
        }
        
        requestAnimationFrame(animate);
    </script>
</body>
</html>